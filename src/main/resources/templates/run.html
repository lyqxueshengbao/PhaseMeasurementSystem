<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>一键测量 - 比相/时延测量上位机</title>
    <link rel="stylesheet" href="/app.css"/>
</head>
<body>
<header>
    <div style="font-size:18px;font-weight:700;">比相/时延测量上位机</div>
    <nav>
        <a href="/ui/devices">设备状态</a>
        <a href="/ui/recipes">配方管理</a>
        <a href="/ui/run">一键测量</a>
    </nav>
    <span class="muted">Run 落盘: ./data/runs/{runId}/</span>
</header>

<div class="card">
    <div class="row">
        <div style="font-weight:700;">选择配方</div>
        <select id="recipeSelect"></select>
        <button class="primary" onclick="startRun()">开始</button>
        <span class="muted">最近运行：</span>
        <select id="recentRunSelect" style="min-width:320px;"></select>
        <button onclick="attachRecentRun()">打开</button>
        <button onclick="refreshRunList()">刷新</button>
        <span class="muted">或恢复 runId：</span>
        <input id="runIdInput" placeholder="RUN-YYYYMMDD-HHMMSS-XXX" style="min-width:260px;"/>
        <button onclick="attachRunFromInput()">恢复</button>
        <span class="muted">（流程：INIT→CHECK_DEVICES→APPLY_RECIPE→LOCK_START→WAIT_LOCKED→MEASURE→SUMMARY→DONE）</span>
    </div>
    <div class="row" style="margin-top:8px;">
        <div>runId：</div>
        <div id="runId" style="font-family: ui-monospace, Menlo, Consolas, monospace;">-</div>
        <div style="margin-left:18px;">MAIN DDS控制字(Hz)：</div>
        <div id="mainDds" style="font-family: ui-monospace, Menlo, Consolas, monospace;">-</div>
        <div style="margin-left:18px;">当前步骤：</div>
        <div id="step" class="badge">-</div>
        <div style="margin-left:18px;">状态：</div>
        <div id="state" class="badge">-</div>
        <a id="zipLink" href="#" style="margin-left:auto;display:none;">下载run.zip</a>
    </div>
</div>

<div class="grid" style="margin-top:12px;">
    <div class="card">
        <div style="font-weight:700;margin-bottom:8px;">实时日志（SSE）</div>
        <pre id="log" class="log"></pre>
    </div>
    <div class="card">
        <div style="font-weight:700;margin-bottom:8px;">测量结果（每次repeat一条）</div>
        <table>
            <thead>
            <tr>
                <th>模式</th>
                <th>次数</th>
                <th>时延(ps)</th>
                <th>相位(°)</th>
                <th>置信度</th>
                <th>质量</th>
                <th>标准差σ(ps)</th>
            </tr>
            </thead>
            <tbody id="resultsBody"></tbody>
        </table>
        <div style="font-weight:700;margin-top:12px;">大气时延输出</div>
        <div id="atmCard" class="card" style="margin-top:8px;background:#fff;">
            <div class="muted">等待SUMMARY...</div>
        </div>
    </div>
</div>

<div class="card" style="margin-top:12px;">
    <div style="font-weight:700;margin-bottom:8px;">run目录文件</div>
    <div id="files" class="muted">-</div>
</div>

<script>
    let es = null;
    let currentRunId = null;
    let results = [];

    function setBadge(id, text, cls) {
        const el = document.getElementById(id);
        el.className = cls || 'badge';
        el.textContent = text;
    }

    function appendLog(line) {
        const log = document.getElementById('log');
        const s = normalizeNewlines(line);
        log.append(document.createTextNode(s));
        if (!s.endsWith('\n')) log.append(document.createTextNode('\n'));
        log.scrollTop = log.scrollHeight;
    }

    function normalizeNewlines(s) {
        if (s === null || s === undefined) return '';
        return String(s)
            .replace(/\\r\\n/g, '\n')
            .replace(/\\n/g, '\n')
            .replace(/\/n/g, '\n')
            .replace(/\r\n/g, '\n')
            .replace(/\r/g, '\n');
    }

    function qualityClass(q) {
        if (q === 'OK') return 'badge ok';
        if (q === 'WARN') return 'badge warn';
        if (q === 'BAD') return 'badge bad';
        if (q === 'INVALID') return 'badge invalid';
        return 'badge';
    }

    function modeLabel(mode) {
        if (mode === 'LINK') return '链路(LINK)';
        if (mode === 'MAIN_INTERNAL') return '主站内环(MAIN_INTERNAL)';
        if (mode === 'RELAY_INTERNAL') return '转发站内环(RELAY_INTERNAL)';
        return mode || '-';
    }

    function fmt(v, digits) {
        if (v === null || v === undefined) return '-';
        const n = Number(v);
        if (!Number.isFinite(n)) return '-';
        if (digits === undefined || digits === null) return String(n);
        return n.toFixed(digits);
    }

    function nsToPs(ns) {
        const n = Number(ns);
        if (!Number.isFinite(n)) return null;
        return n * 1000.0;
    }

    function renderResults() {
        const tbody = document.getElementById('resultsBody');
        tbody.innerHTML = '';
        results.forEach(r => {
            const tr = document.createElement('tr');
            const delayPs = nsToPs(r.delayNs);
            const stdNs = r.explain && r.explain.mcStdDelayNs !== undefined ? r.explain.mcStdDelayNs : null;
            const stdPs = nsToPs(stdNs);
            tr.innerHTML = `
              <td>${modeLabel(r.mode)}</td>
              <td>${fmt(r.repeatIndex, 0)}</td>
              <td>${fmt(delayPs, 3)}</td>
              <td>${fmt(r.phaseDeg, 3)}</td>
              <td>${fmt(r.confidence, 3)}</td>
              <td><span class="${qualityClass(r.qualityFlag)}">${r.qualityFlag}</span></td>
              <td>${fmt(stdPs, 3)}</td>`;
            tbody.appendChild(tr);
        });
    }

    async function refreshRecipeList() {
        let body;
        try {
            const res = await fetch('/api/recipes');
            body = await res.json();
        } catch (e) {
            appendLog('[WARN] 获取配方列表失败：' + (e && e.message ? e.message : e));
            return;
        }
        const sel = document.getElementById('recipeSelect');
        sel.innerHTML = '';
        (body.data || []).forEach(id => {
            const opt = document.createElement('option');
            opt.value = id;
            opt.textContent = id;
            sel.appendChild(opt);
        });
    }

    async function refreshRunList() {
        let body;
        try {
            const res = await fetch('/api/runs');
            body = await res.json();
        } catch (e) {
            appendLog('[WARN] 获取运行列表失败：' + (e && e.message ? e.message : e));
            return;
        }

        const sel = document.getElementById('recentRunSelect');
        sel.innerHTML = '';

        const arr = (body && body.data) ? body.data : [];
        if (!Array.isArray(arr) || arr.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = '(暂无历史运行)';
            sel.appendChild(opt);
            return;
        }

        arr.forEach(ri => {
            const runId = (ri && ri.runId) ? ri.runId : null;
            if (!runId) return;
            const status = (ri && ri.status) ? ri.status : '';
            const recipeId = (ri && ri.recipeId) ? ri.recipeId : '';
            const opt = document.createElement('option');
            opt.value = runId;
            opt.textContent = `${runId}${recipeId ? (' | ' + recipeId) : ''}${status ? (' | ' + status) : ''}`;
            sel.appendChild(opt);
        });
    }

    function attachRecentRun() {
        const runId = (document.getElementById('recentRunSelect').value || '').trim();
        if (!runId) return;
        attachRun(runId);
    }

    function saveLastRunId(runId) {
        try {
            localStorage.setItem('pj125:lastRunId', runId);
        } catch (e) {
            // ignore
        }
        try {
            const u = new URL(window.location.href);
            u.searchParams.set('runId', runId);
            history.replaceState(null, '', u.toString());
        } catch (e) {
            // ignore
        }
    }

    function getPreferredRunId() {
        try {
            const u = new URL(window.location.href);
            const q = u.searchParams.get('runId');
            if (q) return q;
        } catch (e) {
            // ignore
        }
        try {
            const v = localStorage.getItem('pj125:lastRunId');
            if (v) return v;
        } catch (e) {
            // ignore
        }
        return null;
    }

    async function startRun() {
        if (es) { es.close(); es = null; }
        results = [];
        renderResults();
        document.getElementById('log').textContent = '';
        document.getElementById('atmCard').innerHTML = '<div class="muted">等待SUMMARY...</div>';
        document.getElementById('files').textContent = '-';
        document.getElementById('zipLink').style.display = 'none';

        const recipeId = document.getElementById('recipeSelect').value;
        const res = await fetch('/api/runs', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({recipeId})
        });
        const body = await res.json();
        if (!body.success) {
            appendLog('[ERROR] ' + body.message);
            return;
        }
        currentRunId = body.data.runId;
        document.getElementById('runId').textContent = currentRunId;
        document.getElementById('runIdInput').value = currentRunId;
        saveLastRunId(currentRunId);
        await refreshRunList();
        setBadge('state', 'RUNNING');
        setBadge('step', 'INIT');
        subscribeSse(currentRunId);
    }

    function attachRunFromInput() {
        const runId = (document.getElementById('runIdInput').value || '').trim();
        if (!runId) return;
        attachRun(runId);
    }

    async function attachRun(runId) {
        if (es) { es.close(); es = null; }

        results = [];
        renderResults();
        document.getElementById('log').textContent = '';
        document.getElementById('atmCard').innerHTML = '<div class="muted">加载中...</div>';
        document.getElementById('files').textContent = '-';
        document.getElementById('zipLink').style.display = 'none';

        currentRunId = runId;
        document.getElementById('runId').textContent = runId;
        document.getElementById('runIdInput').value = runId;
        saveLastRunId(runId);

        setBadge('state', 'RUNNING');
        setBadge('step', '-');

        await refreshRunInfo(runId);
        await refreshFiles(runId);
        await refreshPersistedResults(runId);
        await refreshPersistedAtmospheric(runId);
        subscribeSse(runId);
    }

    function subscribeSse(runId) {
        es = new EventSource(`/api/sse/runs/${runId}`);
        es.onmessage = (ev) => {}; // unused
        es.addEventListener('LOG', ev => {
            const env = JSON.parse(ev.data);
            const p = env.payload || {};
            appendLog(`[${env.seq}] ${p.step || '-'} ${normalizeNewlines(p.message)}`);
        });
        es.addEventListener('STEP', ev => {
            const env = JSON.parse(ev.data);
            const p = env.payload || {};
            setBadge('step', p.step || '-', 'badge warn');
        });
        es.addEventListener('DEVICE_STATUS', ev => {
            const env = JSON.parse(ev.data);
            const s = env.payload || {};
            // optional: could render separate device status, here we just log state changes
        });
        es.addEventListener('MEASUREMENT_RESULT', ev => {
            const env = JSON.parse(ev.data);
            const r = env.payload;
            upsertResult(r);
            renderResults();
        });
        es.addEventListener('ATMOSPHERIC_RESULT', ev => {
            const env = JSON.parse(ev.data);
            const a = env.payload;
            const snap = a.inputsSnapshot || {};
            const detail = JSON.stringify(snap, null, 2);
            document.getElementById('atmCard').innerHTML = `
              <div>status: <span class="badge ok">${a.status}</span></div>
              <div style="margin-top:6px;">atmosphericDelayNs: <b>${a.atmosphericDelayNs}</b> ns</div>
              <div>uncertaintyNs: ${a.uncertaintyNs} ns</div>
              <div class="muted">formulaVersion: ${a.formulaVersion}</div>
              <pre class="muted" style="white-space:pre-wrap;margin-top:8px;">${detail}</pre>`;
        });
        es.addEventListener('DONE', async ev => {
            const env = JSON.parse(ev.data);
            setBadge('state', 'SUCCEEDED', 'badge ok');
            setBadge('step', 'DONE', 'badge ok');
            await refreshFiles(runId);
            await refreshRunInfo(runId);
            es.close();
        });
        es.addEventListener('FAILED', async ev => {
            const env = JSON.parse(ev.data);
            const p = env.payload || {};
            setBadge('state', 'FAILED', 'badge bad');
            setBadge('step', 'FAILED', 'badge bad');
            appendLog(`[FAILED] ${p.errorCode || ''} ${normalizeNewlines(p.message || '')}`);
            try {
                const res = await fetch(`/api/runs/${runId}/atmospheric_delay`);
                const body = await res.json();
                const data = body.data || {};
                document.getElementById('atmCard').innerHTML = `
                  <div class="bad">运行失败：${body.message || p.message || ''}</div>
                  <pre class="muted" style="white-space:pre-wrap;margin-top:8px;">${JSON.stringify(data, null, 2)}</pre>`;
            } catch (e) {
                document.getElementById('atmCard').innerHTML = `<div class="bad">运行失败：${p.message || ''}</div>`;
            }
            await refreshFiles(runId);
            await refreshRunInfo(runId);
            es.close();
        });
        es.onerror = (e) => {
            // allow refresh
        };
    }

    function upsertResult(r) {
        if (!r) return;
        const key = `${r.mode || ''}|${r.repeatIndex}`;
        for (let i = 0; i < results.length; i++) {
            const x = results[i];
            const k = `${x.mode || ''}|${x.repeatIndex}`;
            if (k === key) {
                results[i] = r;
                return;
            }
        }
        results.push(r);
    }

    async function refreshPersistedResults(runId) {
        try {
            const res = await fetch(`/api/runs/${runId}/measurement_result`);
            const body = await res.json();
            if (body && body.success && body.data && Array.isArray(body.data.results)) {
                results = body.data.results || [];
                renderResults();
            }
        } catch (e) {
            // ignore
        }
    }

    async function refreshPersistedAtmospheric(runId) {
        try {
            const res = await fetch(`/api/runs/${runId}/atmospheric_delay`);
            const body = await res.json();
            if (!body) return;
            if (body.success) {
                const a = body.data || {};
                const snap = a.inputsSnapshot || {};
                const detail = JSON.stringify(snap, null, 2);
                document.getElementById('atmCard').innerHTML = `
                  <div>status: <span class="badge ok">${a.status}</span></div>
                  <div style="margin-top:6px;">atmosphericDelayNs: <b>${a.atmosphericDelayNs}</b> ns</div>
                  <div>uncertaintyNs: ${a.uncertaintyNs} ns</div>
                  <div class="muted">formulaVersion: ${a.formulaVersion}</div>
                  <pre class="muted" style="white-space:pre-wrap;margin-top:8px;">${detail}</pre>`;
            } else {
                const data = body.data || {};
                if (data && data.errorCode === 'NOT_READY') {
                    document.getElementById('atmCard').innerHTML = '<div class="muted">等待SUMMARY...</div>';
                    return;
                }
                document.getElementById('atmCard').innerHTML = `
                  <div class="bad">运行失败：${body.message || ''}</div>
                  <pre class="muted" style="white-space:pre-wrap;margin-top:8px;">${JSON.stringify(data, null, 2)}</pre>`;
            }
        } catch (e) {
            // ignore
        }
    }

    async function refreshFiles(runId) {
        const res = await fetch(`/api/runs/${runId}/files`);
        const body = await res.json();
        if (!body.success) return;
        const files = body.data || {};
        const lines = Object.entries(files).map(([k, v]) => `${k} (${v} bytes)`).join(' | ');
        document.getElementById('files').textContent = lines || '-';
        const zip = document.getElementById('zipLink');
        zip.href = `/api/runs/${runId}/archive`;
        zip.style.display = 'inline';
    }

    async function refreshRunInfo(runId) {
        try {
            const res = await fetch(`/api/runs/${runId}`);
            const body = await res.json();
            const cfg = (body.data || {}).mainAppliedConfig || {};
            const hz = cfg.ddsFreqHz;
            document.getElementById('mainDds').textContent = (hz === null || hz === undefined) ? '-' : hz;
            const status = (body.data || {}).status;
            if (status) {
                if (status === 'SUCCEEDED') setBadge('state', status, 'badge ok');
                else if (status === 'FAILED') setBadge('state', status, 'badge bad');
                else setBadge('state', status, 'badge warn');
            }
            const step = (body.data || {}).step;
            if (step) setBadge('step', step, 'badge warn');
        } catch (e) {
            document.getElementById('mainDds').textContent = '-';
        }
    }

    async function initPage() {
        await refreshRecipeList();
        await refreshRunList();
        const preferred = getPreferredRunId();
        if (preferred) {
            await attachRun(preferred);
        }
    }

    initPage();
</script>
</body>
</html>
